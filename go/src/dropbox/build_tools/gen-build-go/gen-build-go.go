// Generate a Bazel BUILD file from a list of packages.
// Invoke this exactly as "go build"
package main

import (
	"bytes"
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"go/build"
	"io"
	"io/ioutil"
	"log"
	"os"
	"path"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/bazelbuild/buildtools/wspace"
	"golang.org/x/mod/modfile"
	"golang.org/x/mod/module"

	buildlib "dropbox/build_tools/genbuildgolib"
)

const (
	workspaceFile = "WORKSPACE"

	buildHeaderTmpl = `load('@dbx_build_tools//build_tools/go:go.bzl', 'dbx_go_binary', 'dbx_go_library', 'dbx_go_test')

`
)

// determineTargetBuildPath uses a series of ways to try to
// determine the major version of the module that `bzl gen` is
// running on.
func determineTargetBuildPath(dir string) string {
	if !isVersionExplicitModule(dir) {
		return ""
	}

	wsRoot, _ := wspace.FindWorkspaceRoot("")
	srcPath := filepath.Join(wsRoot, "go", "src")
	targetRelPath, _ := filepath.Rel(srcPath, dir)
	submoduleRelPath := ""
	_, err := os.Stat(filepath.Join(dir, ".dbxvendor.json"))
	for err != nil {
		if dir == srcPath {
			return ""
		}
		submoduleRelPath = filepath.Join(filepath.Base(dir), submoduleRelPath)
		dir = filepath.Dir(dir)
		_, err = os.Stat(filepath.Join(dir, ".dbxvendor.json"))
	}

	targetBuildPath, ok := parseTargetBuildPathFromDbxvendorMetadata(dir, submoduleRelPath)
	if ok && targetRelPath != targetBuildPath {
		return targetBuildPath
	}
	return ""
}

// parseTargetBuildPathFromDbxvendorMetadata parses the .dbxvendor.json
// file that is generated by the dbxvendor tool and tries to see if a major
// version has been recorded by it.
func parseTargetBuildPathFromDbxvendorMetadata(dir string, submodulePath string) (string, bool) {
	data, err := ioutil.ReadFile(filepath.Join(dir, ".dbxvendor.json"))
	if err != nil {
		return "", false
	}
	var result map[string]interface{}
	err = json.Unmarshal(data, &result)
	if err != nil {
		return "", false
	}

	if result["Module"] != nil {
		return filepath.Join(result["Module"].(string), submodulePath), true
	} else {
		return "", false
	}
}

func parseDepPathsFromGoModFile(pkg string) map[string]string {
	depToImportPathMap := make(map[string]string)
	dependencies, err := findGoModDeps(pkg)
	if err != nil {
		return nil
	}
	for _, dependency := range dependencies {
		depToImportPathMap[dependency.Path] =
			determineDepPathFromImportAndMajorVersion(dependency.Path, dependency.Version)
	}
	return depToImportPathMap
}

func determineDepPathFromImportAndMajorVersion(importPath, versionString string) string {
	majorVersion := parseMajorVersionNumFromVersionString(versionString)
	if majorVersion == "" || majorVersion == "0" || majorVersion == "1" {
		return importPath
	}
	// We are assuming that go.mod file always contain repo root entries
	// For example, golang.org/x/sys is a repo root, golang.org/x/sys/unit will not exist in go.mod
	return filepath.Join(importPath, "/v"+majorVersion)
}

func parseMajorVersionNumFromVersionString(version string) string {
	regexpObj := regexp.MustCompile(`[vV](?P<majorVersionNum>[0-9]+)([.][0-9.]*|$)`)
	match := regexpObj.FindStringSubmatch(version)
	if len(match) > 0 {
		result := make(map[string]string)
		for i, name := range regexpObj.SubexpNames() {
			if i != 0 && name != "" {
				result[name] = match[i]
			}
		}
		return result["majorVersionNum"]
	}
	return ""
}

func isVersionExplicitModule(dir string) bool {
	wsRoot, _ := wspace.FindWorkspaceRoot("")
	srcPath := filepath.Join(wsRoot, "go", "src")
	_, err := os.Stat(filepath.Join(dir, ".dbxvendor.json"))
	for err != nil {
		if dir == srcPath {
			return false
		}
		dir = filepath.Dir(dir)
		_, err = os.Stat(filepath.Join(dir, ".dbxvendor.json"))
	}
	data, err := ioutil.ReadFile(filepath.Join(dir, ".dbxvendor.json"))
	if err != nil {
		return false
	}
	var result map[string]interface{}
	err = json.Unmarshal(data, &result)
	if err != nil {
		return false
	}

	if result["VersionExplicit"] != nil {
		return true
	} else {
		return false
	}
}

func findGoModDeps(rootPath string) ([]module.Version, error) {
	mfPath := filepath.Join(rootPath, "go.mod")
	modData, err := ioutil.ReadFile(mfPath)
	if err != nil {
		return nil, err
	}
	mf, err := modfile.Parse(mfPath, modData, nil)
	if err != nil {
		return nil, err
	}
	reqs := make([]module.Version, 0, len(mf.Require))
	for _, r := range mf.Require {
		reqs = append(reqs, r.Mod)
	}
	return reqs, nil
}

type ConfigGenerator struct {
	dryRun  bool
	verbose bool

	onlyGenPkgs map[string]struct{}

	workspace string
	goSrc     string

	golangPkgs    map[string]struct{}
	processedPkgs map[string]struct{}

	visitStack []string // for detecting cycles
}

func (g *ConfigGenerator) isBuiltinPkg(pkgName string) bool {
	if g.isDbxPkg(pkgName) {
		return false
	}

	result, hasResult := buildlib.IsBuiltinPkg(pkgName, g.golangPkgs, g.verbose)
	if hasResult {
		return result
	}

	g.golangPkgs[pkgName] = struct{}{}
	return true
}

func (g *ConfigGenerator) isDbxPkg(pkgName string) bool {
	return strings.HasPrefix(pkgName, "dropbox/") ||
		strings.HasPrefix(pkgName, "godropbox/") ||
		strings.HasPrefix(pkgName, "atlas/") ||
		strings.HasPrefix(pkgName, "github.com/dropbox")
}

func (g *ConfigGenerator) createDeps(
	pkg *build.Package,
	pkgs []string,
	gomodDepPaths map[string]string) []string {
	deps := []string{}
	isVersionExplicit := isVersionExplicitModule(filepath.Join(g.workspace, g.goSrc, pkg.ImportPath))

	for _, dep := range pkgs {
		if g.isBuiltinPkg(dep) {
			continue
		}

		depIsInGoMod := false
		if gomodDepPaths != nil && isVersionExplicit {
			for importPath, _ := range gomodDepPaths {
				if strings.HasPrefix(dep, importPath) {
					if dep == importPath {
						if _, err := os.Stat(filepath.Join(g.workspace, g.goSrc, gomodDepPaths[importPath])); err == nil {
							deps = append(deps, "//"+g.goSrc+"/"+gomodDepPaths[importPath])
							depIsInGoMod = true
						}
						break
					} else {
						relativePath, err := filepath.Rel(importPath, dep)
						if err != nil {
							break
						}
						if _, err := os.Stat(filepath.Join(g.workspace, g.goSrc, gomodDepPaths[importPath], relativePath)); err == nil {
							deps = append(deps, "//"+g.goSrc+"/"+filepath.Join(gomodDepPaths[importPath], relativePath))
							depIsInGoMod = true
						}
						break
					}
				}
			}
			if depIsInGoMod == true {
				continue
			}
		}
		deps = append(deps, "//"+g.goSrc+"/"+dep)
	}
	return deps
}

func (g *ConfigGenerator) generateConfig(pkg *build.Package) error {
	if g.verbose {
		fmt.Println("Generating config for", pkg.Dir)
	}

	buffer := &bytes.Buffer{}
	_, _ = buffer.WriteString(buildHeaderTmpl)

	srcs, cgoSrcs := buildlib.InitializeSrcsAndCGOSrcs(pkg)

	cgoIncludeFlags := []string{}
	cgoLinkerFlags := []string{}
	cgoCXXFlags := []string{}
	gomodDepPaths := parseDepPathsFromGoModFile(pkg.Dir)
	deps := g.createDeps(pkg, pkg.Imports, gomodDepPaths)

	cgoIncludeFlags,
		cgoCXXFlags,
		cgoLinkerFlags,
		deps,
		srcs,
		cgoSrcs, err := buildlib.PopulateSrcsAndDeps(pkg, cgoIncludeFlags,
		cgoCXXFlags,
		cgoLinkerFlags,
		deps,
		srcs,
		cgoSrcs)
	if err != nil {
		return err
	}

	name := filepath.Base(pkg.Dir)

	var targetBuildPath string
	targetBuildPath = determineTargetBuildPath(pkg.Dir)

	rule := "dbx_go_library"
	if pkg.Name == "main" {
		rule = "dbx_go_binary"
	}
	writeTarget(
		buffer,
		rule,
		name,
		pkg.ImportPath,
		srcs,
		deps,
		cgoSrcs,
		cgoIncludeFlags,
		cgoLinkerFlags,
		cgoCXXFlags,
		targetBuildPath,
		"",
	)

	// write test target
	if g.isDbxPkg(pkg.ImportPath) {
		if len(pkg.TestGoFiles) > 0 {
			var testSrcs []string
			testSrcs = append(testSrcs, srcs...)
			testSrcs = append(testSrcs, pkg.TestGoFiles...)
			testSrcs = buildlib.UniqSort(testSrcs)

			var testDeps []string
			testDeps = append(testDeps, deps...)
			testDeps = append(testDeps, g.createDeps(pkg, pkg.TestImports, gomodDepPaths)...)
			testDeps = buildlib.UniqSort(testDeps)

			_, _ = buffer.WriteString("\n")
			writeTarget(
				buffer,
				"dbx_go_test",
				name+"_test",
				pkg.ImportPath,
				testSrcs,
				testDeps,
				cgoSrcs,
				cgoIncludeFlags,
				cgoLinkerFlags,
				cgoCXXFlags,
				targetBuildPath,
				"",
			)
		}

		if len(pkg.XTestGoFiles) > 0 {
			xTestSrcs := buildlib.UniqSort(pkg.XTestGoFiles)
			xTestDeps := buildlib.UniqSort(g.createDeps(pkg, pkg.XTestImports, gomodDepPaths))

			_, _ = buffer.WriteString("\n")
			writeTarget(
				buffer,
				"dbx_go_test",
				name+"_ext_test",
				pkg.ImportPath,
				xTestSrcs,
				xTestDeps,
				nil,
				nil,
				nil,
				nil,
				targetBuildPath,
				pkg.ImportPath+"_test",
			)
		}
	}

	return buildlib.WriteToBuildConfigFile(g.dryRun, pkg, *buildFilename, buffer)
}

func (g *ConfigGenerator) Process(goPkgPath string) error {
	err := g.process(goPkgPath)
	if err != nil {
		return errors.New("Failed to process " + goPkgPath + ": " + err.Error())
	}

	return nil
}

func (g *ConfigGenerator) process(goPkgPath string) error {
	pkg, err := buildlib.PopulatePackageInfo(
		goPkgPath,
		g.workspace,
		g.goSrc,
		g.verbose,
		g.isBuiltinPkg(goPkgPath),
		g.processedPkgs,
		g.visitStack)
	if pkg == nil {
		return err
	}

	// Generate config files for dependencies first.
	visit := func(toVisit []string) error {
		for _, dep := range toVisit {
			if dep == goPkgPath { // can include self in tests
				continue
			}

			shouldGenerate := true
			if g.onlyGenPkgs != nil {
				_, shouldGenerate = g.onlyGenPkgs[dep]
			}

			if shouldGenerate {
				err = g.Process(dep)
				if err != nil {
					return err
				}
			}
		}
		return nil
	}

	// NOTE: pkg.XTestImports is not visited.
	err = visit(pkg.Imports)
	if err != nil {
		return err
	}
	if g.isDbxPkg(goPkgPath) {
		err = visit(pkg.TestImports)
		if err != nil {
			return err
		}
	}

	genErr := g.generateConfig(pkg)
	if genErr != nil {
		return genErr
	}

	g.processedPkgs[goPkgPath] = struct{}{}
	return nil
}

func writeTarget(
	buffer io.StringWriter,
	rule string,
	name string,
	pkgPath string,
	srcs []string,
	deps []string,
	cgoSrcs []string,
	cgoIncludeFlags []string,
	cgoLinkerFlags []string,
	cgoCXXFlags []string,
	targetBuildPath string,
	moduleName string,
) {
	buildlib.WriteCommonBuildAttrToTarget(
		buffer,
		rule,
		name,
		srcs,
		deps,
		cgoSrcs,
		cgoIncludeFlags,
		cgoLinkerFlags,
		cgoCXXFlags,
		moduleName)

	if rule == "dbx_go_library" {
		if len(targetBuildPath) > 0 {
			_, _ = buffer.WriteString(" module_name = '" + targetBuildPath + "',\n")
		}

		internalParentPath := pkgPath
		component := ""
		hasInternal := false
		for internalParentPath != "." {
			internalParentPath, component = path.Split(internalParentPath)
			internalParentPath = filepath.Clean(internalParentPath)

			if component == "internal" {
				hasInternal = true
				break
			}
		}

		if hasInternal && !strings.HasPrefix(pkgPath, "dropbox/proto/") {
			_, _ = buffer.WriteString("  visibility=[\n")
			_, _ = buffer.WriteString("    '//go/src/")
			_, _ = buffer.WriteString(internalParentPath)
			_, _ = buffer.WriteString(":__subpackages__',\n")
			_, _ = buffer.WriteString("  ],\n")
		} else if strings.HasPrefix(pkgPath, "dropbox/") {
			// In general, 3rd party packages (including godropbox)
			// should not import from dropbox/...

			_, _ = buffer.WriteString("  visibility=[\n")
			_, _ = buffer.WriteString(
				"    '//go/src/atlas:__subpackages__',\n")
			_, _ = buffer.WriteString(
				"    '//go/src/dropbox:__subpackages__',\n")

			if pkgPath == "dropbox/proto/mysql" {
				// The internal dropbox/proto/mysql definitions is a
				// superset of the open sourced definitions.
				_, _ = buffer.WriteString(
					"    '//go/src/godropbox/database/binlog:__subpackages__',\n")
			}

			_, _ = buffer.WriteString("  ],\n")
		} else if strings.HasPrefix(pkgPath, "atlas/") {
			// In general, only the same service should import from atlas/<service>/...
			_, _ = buffer.WriteString("  visibility=[\n")
			service := strings.Split(pkgPath, "/")[1]
			_, _ = buffer.WriteString(
				fmt.Sprintf("    '//go/src/atlas/%s:__subpackages__',\n", service))
			_, _ = buffer.WriteString("  ],\n")
		} else {
			// 3rd party packages are public to go code.
			_, _ = buffer.WriteString("  visibility=[\n")
			_, _ = buffer.WriteString("    '//go/src:__subpackages__',\n")
			_, _ = buffer.WriteString("  ],\n")
		}
	} else if rule == "dbx_go_binary" {
		// NOTE: for now go binaries default to public.
		_, _ = buffer.WriteString("  visibility=[\n")
		_, _ = buffer.WriteString("    '//visibility:public',\n")
		_, _ = buffer.WriteString("  ]\n")
	}

	_, _ = buffer.WriteString(")\n")
}

func findWorkspace(startingDir string) (string, error) {
	checkDir := startingDir
	for {
		if checkDir == "/" {
			return "", fmt.Errorf("directory not in a Bazel workspace: %v", startingDir)
		}
		if _, err := os.Stat(path.Join(checkDir, workspaceFile)); err == nil {
			return checkDir, nil
		}
		checkDir = path.Dir(checkDir)
	}
}

func usage() {
	fmt.Fprintf(os.Stderr, "Usage of %s:\n", os.Args[0])
	flag.PrintDefaults()
	fmt.Fprintf(os.Stderr, `
Examples:

Generate a BUILD file in current directory:

  gen-build-go

Generate a BUILD file for a package in the WORKSPACE-implied GOPATH:
  NOTE: This tool ignores the GOPATH environment variable.

  gen-build-go dropbox/dbxinit/dbxinitctl

`)
}

var buildFilename = flag.String(
	"build-filename",
	"BUILD",
	"The name of the build file to write.")

func main() {
	flag.Usage = usage
	dryRun := flag.Bool("dry-run", false, "dry run - just echo BUILD files")
	verbose := flag.Bool("verbose", false, "show more detail during analysis")
	skipDepsGeneration := flag.Bool(
		"skip-deps-generation",
		false,
		"When true, only generate BUILD files for the specified packages")
	flag.Parse()
	log.SetFlags(0)

	cwd, err := os.Getwd()
	if err != nil {
		log.Fatal("Unable to get cwd:", err)
	}
	workspace, err := findWorkspace(cwd)
	if err != nil {
		log.Fatal("Unable to find workspace:", err)
	}

	// Force GOPATH to be defined by the workspace.
	build.Default.GOPATH = path.Join(workspace, "go")

	packages := flag.Args()
	if len(packages) == 0 {
		log.Fatal("No package specified")
	}

	var onlyGenPkgs map[string]struct{} = nil
	if *skipDepsGeneration {
		onlyGenPkgs = make(map[string]struct{})
		for _, pkg := range packages {
			onlyGenPkgs[pkg] = struct{}{}
		}
	}

	generator := &ConfigGenerator{
		dryRun:        *dryRun,
		verbose:       *verbose,
		onlyGenPkgs:   onlyGenPkgs,
		workspace:     workspace,
		goSrc:         "go/src",
		golangPkgs:    make(map[string]struct{}),
		processedPkgs: make(map[string]struct{}),
	}

	var lastErr error
	for _, pkg := range packages {
		if err := generator.Process(pkg); err != nil {
			lastErr = err
		}
	}

	if lastErr != nil {
		log.Fatal("Failed to create all configs:", lastErr)
	}
}
